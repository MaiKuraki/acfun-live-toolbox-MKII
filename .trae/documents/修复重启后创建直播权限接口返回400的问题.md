## 问题与根因
- 现象：重启后点击“创建直播”请求 `GET /api/acfun/live/permission` 返回 400；登出再登录后恢复正常（`packages/renderer/src/pages/LiveCreatePage.vue:412`）。
- 根因：主进程在令牌再水化阶段仅将 `serviceToken` 写入认证头，缺失 `securityKey/cookies/deviceID/userID` 等必需字段，导致代理无法签名并被上游拒绝。
  - 证据：
    - 再水化路径仅设置 `serviceToken`（`packages/main/src/server/TokenManager.ts:520-522`）。
    - HTTP 客户端将 `Authorization` 视为 JSON 串并严格 `JSON.parse`（`packages/main/node_modules/acfunlive-http-api/dist/core/HttpClient.js:151-158, 180-188`）。
    - 非 JSON 的 `Authorization` 会被包装为占位 `tokenInfo`（`packages/main/node_modules/acfunlive-http-api/dist/AcFunLiveApi.js:30-52`），不含真实 cookies/securityKey。
    - 权限端点代理位置（`packages/main/src/server/AcfunApiProxy.ts:453-461`）。

## 变更方案
1) 统一令牌应用格式
- 将再水化时的 `setAuthToken(this.tokenInfo.serviceToken)` 改为传入完整 JSON：`setAuthToken(JSON.stringify({ userID, securityKey, serviceToken, deviceID, cookies }))`。
- 更安全的做法：在 `loadTokenInfo()` 成功解析后直接复用内部管线 `await setTokenInfo(parsed)`，避免重复逻辑与格式偏差。

2) 启动时初始化令牌
- 在主进程启动路径（创建 `ApiServer` 之前）调用一次 `TokenManager.initialize()`，确保 `Authorization` 已设置并刷新计时器已开启。

3) 适配器稳健性一致化
- 将 `AcfunAdapter.ensureAuthentication()` 中的“再次应用令牌”也改为传入完整 JSON（或移除该重复设置，统一由 `TokenManager` 负责），防止覆盖已正确的认证头。

4) 守卫与日志
- 在 `AcfunApiProxy` 的敏感端点（如 `stream-status/transcode-info` 已有示例）使用 `httpClient.getValidatedTokenInfo()`，缺 token 返回 401 并打印关键字段，便于诊断。

## 验证步骤（静态）
- 重启后（不手动登出/登录），调用：
  - `GET /api/acfun/auth/status` 应显示 `authenticated: true`（如有有效令牌）。
  - `GET /api/acfun/live/permission` 应返回 `200` 且包含 `liveAuth`。
- 人为清空令牌后：`DELETE /api/acfun/auth/token` → 再次请求上述端点应返回 401/400。
- 再登录后：二维码登录完成 → 权限端点恢复 200。

## 影响面与兼容
- 无外部接口变更；仅修正内部令牌再水化与应用方式，符合库对 `Authorization` 为 JSON 的约定。
- 删除冗余的重复 `setAuthToken(serviceToken)` 逻辑，避免覆盖正确头。