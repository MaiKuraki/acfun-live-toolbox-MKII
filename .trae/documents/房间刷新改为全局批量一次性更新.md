## 目标
- 将每次刷新从“逐房间并行 + 逐房间落盘”改为“全局批量拉取 → 一次性合并更新”，避免同一刷新周期内对同一房间发生多次 UI 更新，降低闪烁。

## 实施要点
- 文件：`packages/renderer/src/stores/room.ts`
- 函数：`refreshRoomStatus()`

### 1) 增加刷新互斥与节流
- 新增 `isRefreshing: boolean` 标志，刷新开始时置 `true`，结束后置 `false`，并在开始处短路返回避免并发。
- 可选：在外层定时器调用处增加最小刷新间隔保护（防抖/节流）。

### 2) 全局 Promise.allSettled 批量拉取
- 现有做法：对每个房间并行 `Promise.all([status, details])`，然后就地更新；这仍会在不同房间的不同时间点落盘，导致多次微更新。
- 改为两轮批量：
  1. `statuses = Promise.allSettled(rooms.map(r => room.status(r.id)))`
  2. `details = Promise.allSettled(rooms.map(r => room.details(r.id)))`
- 两轮全部完成后，进入合并阶段，一次性更新所有房间。

### 3) 合并策略（容错）
- 为每个房间构建 `next`：
  - 若 `statuses[i]` 成功：映射 `status/isLive/connectedAt/lastEventAt/lastUpdate`
  - 若失败：不改 `status/isLive`（或设为 `disconnected` 但仅在明确错误时）
  - 若 `details[i]` 成功：映射 `title/coverUrl/viewerCount/likeCount/startTime/streamer`
  - 若失败：不改对应字段
- 只对发生变化的字段执行 `Object.assign(room, next)`（先做浅比较，避免无效写入触发响应式抖动）。
- 不替换 `rooms.value` 数组，严格就地更新对象，按一次循环统一落盘。

### 4) 单次提交更新
- 在所有 `next` 合并完成后，做一个 for 循环，逐房间执行 `Object.assign`，只提交一次批量更新。
- 刷新后执行 `saveRoomsToStorage()` 一次。

### 5) 按钮与标签稳定策略（页面）
- 操作区改为三槽位并使用 `v-show`，按钮始终渲染，占位稳定：
  - 采集按钮：`connected → 断开采集；connecting → 连接采集中（禁用）；else → 连接采集`
  - 查看弹幕：常显
  - 进入直播间：常显，`disconnected` 时禁用
- 双标签显示：
  - 左：`room.isLive → 直播中/未直播`
  - 右：`room.status → 😊 弹幕获取中/未连接采集/⏳ 连接采集中/采集错误`
- 将 `.room-item` 过渡限定为 `border-color/background-color`，避免显示/尺寸过渡引起闪烁。

## 验证
- 进入房间管理页：按钮数量不再出现“3→2→3”跳变；状态与按钮文案只在批量更新时统一切换。
- 定时刷新周期：只看到一次统一更新，无多次微更新。
- 容错：某些房间请求失败时，该房间保持旧数据，其他房间正常更新。

## 备注
- 不修改主进程；仅优化 Pinia 刷新与页面渲染策略。
- 后续可选：在窗口不可见时暂停刷新，回到前台时恢复。