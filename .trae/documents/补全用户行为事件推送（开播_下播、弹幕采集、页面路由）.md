## 目标
- 将开播/下播、弹幕采集启停、页面路由切换与房间状态变化统一到同一个 SSE 接口（沿用 `/sse/plugins/:pluginId/overlay`）。

## 事件规范（统一流）
- SSE 端点：`GET /sse/plugins/:pluginId/overlay`
- 事件类别（`meta.kind`）：
  - `room`：房间相关，包括 `room-status-change`、`live-start`、`live-stop`、`danmu-start`、`danmu-stop`
  - `ui`：主窗口路由相关，包括 `route-changed`
- 事件数据（统一结构）：`{ id, meta: { kind }, payload }`
  - `payload.event`：上述语义名（供客户端区分）
  - `payload.data`：具体字段（例如 `{ roomId, status }`、`{ liveId, title, streamName }`、`{ liverUID, sessionId }`、`{ routePath, pageName, pageTitle }`）

## 实施方案
### 1) 后端推送（Room/Live/Danmu → 同流）
- 修改 `packages/main/src/server/AcfunApiProxy.ts`：
  - `live/start|stop` 成功时：遍历已启用插件，向 `plugin:<pluginId>:overlay` 发布 `{ event: 'live-start'|'live-stop', data: { liveId, title, streamName, ts } }`，`meta.kind: 'room'`
  - `danmu/start|stop` 成功时：发布 `{ event: 'danmu-start'|'danmu-stop', data: { liverUID, sessionId?, ts } }`，`meta.kind: 'room'`
- 保持现有 `room-status-change` 推送（已在 `index.ts` 统一到 `plugin:<pluginId>:overlay`），与上述事件同流。

### 2) 前端路由推送（UI → 同流）
- 修改 `packages/renderer/src/router/index.ts`：
  - 在 `router.afterEach` 中调用一个统一上报器：
    - 只读仓库：`reportReadonlyUpdate({ ui: { routePath, pageName, pageTitle } })`（现有SSE订阅方式）
    - 同步到插件流：通过预加载桥或 HTTP 入队 `POST /api/plugins/:pluginId/overlay/messages`，广播 `{ event: 'route-changed', payload: { routePath, pageName, pageTitle } }`，`meta.kind` 将在后端桥接成 `ui`（保持与同流一致）
  - 若广播成本过高，可仅保留只读仓库并在包装页把 `readonly-store-update` 转发为 `route-changed`（推荐）。

## 客户端消费
- 插件页面（包装页）无需新增端点，只需在已有 `/sse/plugins/:pluginId/overlay` 流上监听：
  - `kind: 'room'` → `room-status-change`、`live-start|live-stop`、`danmu-start|danmu-stop`
  - `kind: 'ui'` → `route-changed`
- 继续可选订阅只读仓库：`GET /sse/renderer/readonly-store/subscribe?keys=ui` 获取结构化路由信息。

## 文档同步
- 更新 `API-Core-1.0.0.md`：在插件SSE章节加入“用户行为事件（与房间事件同流）”与“路由事件”说明与示例。
- 更新 `endpoints.apidoc.js`：在相关端点说明成功后会发布统一流事件。

## 验证
- 通过调用 `POST /api/acfun/live/start|stop` 与 `POST /api/acfun/danmu/start|stop` 验证同流事件；路由跳转后验证 `route-changed` 同流推送（或包装页转发）。