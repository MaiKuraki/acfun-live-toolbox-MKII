**诊断结论**
- 事件已开始获取，但持久化仅在 `AcfunApiProxy` 路径接入（start 端点），若插件或其他模块通过 `ApiBridge`/`AcfunAdapter` 启动，则当前不会写入新表，导致“表存在但无数据”。
- acfunlive-http-api 的回调事件形状符合设计：
  - 行为事件使用 `actionType`（comment/gift/throwBanana/...），状态/通知事件使用 `type`（displayInfo/topUsers/...）。
  - `recentComment` 会先逐条回调每条评论的简化对象 `{ sendTime, userInfo, content }`，随后再回调包裹对象 `{ type:"recentComment", data:[...] }`。现有写入器会处理包裹对象，但会忽略“简化对象”，可增强以兼容。

**改动范围**
- 在插件桥接层 `packages/main/src/plugins/ApiBridge.ts:612-616` 接入持久化写入，使所有通过插件启动的弹幕都会落库。
- 增强 `packages/main/src/persistence/DanmuSQLiteWriter.ts` 的 `handleEvent`：当收到不含 `actionType`/`type` 的 `{ sendTime, userInfo, content }` 形状时，将其当作 `comment` 写入（避免漏写 `recentComment` 的逐条回调）。

**具体实现**
- ApiBridge 接入：
  - 导入 `DanmuSQLiteWriter`，用 `this.databaseManager.getDb()` 构造一次 writer。
  - 改造 `acfun.danmu.startDanmu(liverUID, callback?)`：始终使用一个包装回调 `wrapped(e)`，先 `writer.handleEvent(liverUID, e)`，再调用用户传入的 `callback`（若存在），保持原有行为不中断。
- 写入器增强：
  - 在 `DanmuSQLiteWriter.handleEvent` 的最前面增加分支：当 `evt` 同时包含 `sendTime` 与 `userInfo` 且缺少 `actionType/type` 时，构造 `{ actionType:'comment', danmuInfo:{ sendTime:evt.sendTime, userInfo:evt.userInfo }, content:evt.content }` 并走行为事件插入逻辑。

**验证与观测**
- 保持 WAL/索引策略不变，仅进行静态类型检查（`pnpm -C packages\main typecheck`）。
- 运行后，调用插件/桥接层启动弹幕，将在 `users`、`live_actions`、`live_states` 插入：
  - 行为事件：`comment/gift/throwBanana/richText/...`
  - 状态事件：`bananaCount/displayInfo/topUsers/recentComment/...`（含 `recentComment` 逐条转换与整组快照）
- 最终可使用现有 `QueryService` 读取 `events` 表以外的数据需要扩展；本次聚焦新表入库。

**不涉及**
- 不影响 `AcfunApiProxy` 现有路径（仍保留），不改动测试与启动服务器策略。

请确认，我将按以上方案修改 ApiBridge 与 DanmuSQLiteWriter，并进行类型检查。