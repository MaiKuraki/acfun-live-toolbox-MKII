## 当前架构概览

* 包结构：`pnpm` 工作区，核心包 `@app/main`、`@app/preload`、`@app/renderer`，辅助包 `@app/electron-versions`；入口 `packages/entry-point.mjs`，打包配置 `electron-builder.mjs`。

* 主进程：集中调度与服务封装（HTTP/SSE/WS、插件、数据层、诊断）。启动流程与依赖注入在 `packages/main/src/index.ts:48-116`，窗口在 `bootstrap/WindowManager.ts:17-67`，IPC 汇总在 `ipc/ipcHandlers.ts`。

* 渲染层：Vue3 + Pinia + TDesign + Wujie，入口 `packages/renderer/src/main.ts`，路由 `packages/renderer/src/router/index.ts`，只读仓库通过 `/api/renderer/readonly-store` + SSE 分发 `ApiServer.ts:1048-1119`。

* 插件系统：进程型与纯静态托管型并存，统一静态托管与路由作用域由 `server/ApiServer.ts` 与 `plugins/PluginManager.ts` 协作；示例插件见 `buildResources/plugins/*`，窗口示例 `sample-overlay-window/index.js`。

* 本地服务：Express + Helmet/CORS/Compression/Morgan，SSE 心跳 15s（Overlay 与 Renderer）`ApiServer.ts:759-763/1105-1110`；WS 心跳 30s `WsHub.ts:242`；AcFun 代理入口 `/api/acfun/*`（统一限流 `ApiRateLimitManager.ts`）。

* 数据层：SQLite（事件表/房间元表 + 索引）`persistence/DatabaseManager.ts:52-85`，批量写入队列 `EventWriter.ts:65-123`，轻量消息中心 `DataManager.ts`。

## 分析维度与方法

* 代码结构审查：

  * 目录与模块边界：依次走查 `packages/main/src/*`、`packages/preload/src/*`、`packages/renderer/src/*`，识别跨域依赖与角色混叠。

  * 统一命名与职责划分：重点排查同名不同义模块与职责重复。

* 技术栈评估：

  * Electron 39 + Vite 7 + Vue3 + Pinia + TDesign；主进程 SSR 构建目标按 Electron Node 版本对齐 `vite.config.js:12`。

  * `acfunlive-http-api` 真实集成，遵循不 mock 的规则（测试用例位于 `test/*`）。

* 依赖关系分析：

  * 生成包与模块依赖图（主进程/预加载/渲染/插件），标注跨层调用方式（IPC/HTTP/SSE/WS）。

  * 检测循环依赖与过度耦合：针对 `plugins/*` 与 `adapter/*`、`server/*` 交叉点重点检查。

* 性能瓶颈检测：

  * SSE/WS 心跳与订阅清理；日志频率与序列化热点；SQLite 写入模式与索引命中。

  * 连接池实现与重试/熔断策略；渲染层只读仓库汇总逻辑的切片合并开销。

## 初步发现（重点问题）

* 命名与职责重复：

  * `ConnectionPoolManager` 在 `plugins/ConnectionPoolManager.ts` 与 `adapter/ConnectionPoolManager.ts` 两处定义，职责分别为通用网络连接池与 AcFun API 连接池，命名冲突易混淆；建议区分命名并明确边界。

  <br />

* 性能一致性：

  * SSE 心跳散布多处（统一 15s）`ApiServer.ts:759-763/896-903/1105-1110` 与 WS `WsHub.ts:242`；建议集中常量配置与清理策略，避免遗漏清理导致资源泄漏。

* 数据层优化空间：

  * SQLite 未见 WAL/同步级别设置（如 `PRAGMA journal_mode=WAL; synchronous=NORMAL`），批插入已使用事务但仍可提升并发读性能。

* 版本/环境：

  * 根 `package.json` 要求 Node `>=23.0.0`（`package.json:16-18`），与 Electron 39 自带 Node 22 不一致；可能造成工具链或 CI 认知偏差。

## 冗余检查与清理计划

* 重复功能：

  * 核查 `plugins/*` 与 `adapter/*` 的连接池、性能监控、缓存/内存池职责重叠；合并或界定边界（按“插件运行时资源 vs AcFun API 访问”的分层）。

* 未使用代码/依赖：

  * 扫描导出未引用（主/预/渲染）；核查 `renderer` 对 `acfunlive-http-api` 的值引入风险（此前已处置，复核 `stores/danmu.ts`）。

* 过度抽象：

  * 评估 `Plugin*Manager` 系列的层次是否过深（性能监控、更新、懒加载、缓存、窗口），收敛到单一协调器 + 具名子模块。

* 低效逻辑：

  * SSE/只读仓库汇总 `ApiServer.ts:1078-1099` 的快照构建，优化切片合并与去重；统一 JSON 序列化开销控制。

* 不必要中间件：

  * 生产环境关闭 `morgan` 或降级日志；压缩过滤策略已区分 SSE，可保留。

## 优化建议（按标准）

* 可维护性：

  * 重命名并拆分连接池：`PluginConnectionPoolManager`（通用连接）与 `AcfunApiConnectionPool`（API 实例），明确导出入口与生命周期；统一事件名。

  * 提取 `SSEHeartbeat`/`SSECleanup` 工具并全站复用；将心跳间隔集中到配置。

  * 收敛 `Plugin*Manager` 结构：`PluginCoordinator` 驱动子能力（窗口/缓存/懒加载/更新/性能），降低跨模块耦合。

* 性能：

  * SQLite：启用 WAL、`synchronous=NORMAL`、调优 `cache_size` 与预编译语句池；批量大小自适应（负载/延迟权衡）。

  * 序列化与日志：按 `NODE_ENV` 或本地配置关闭 verbose `console.*`，改用 `LogManager` 分级；SSE/WS 消息体按需最小化。

  * 连接池：统一重试/熔断策略，观测指标聚合至诊断页；避免双重健康检查带来开销。

* 成本：

  * 构建与打包：`electron-builder` 的工作区文件白名单已实现（`electron-builder.mjs:114-137`），保持最小发版体积；CI 中按平台裁剪。

  * 依赖审查：渲染层尽量仅导入 `acfunlive-http-api` 类型（避免 runtime 依赖）；主进程复用单例 API 实例。

* 扩展性：

  * 插件 API 边界统一经 `ApiBridge` 与 `/api/plugins/:id/*`，规则化变更；Overlay 包装页与路由/SPA/HTML 三模式保持一致入口（已实现，补文档）。

  * 只读仓库作为跨页消息总线规范化（事件名与切片），为后续多插件仪表板奠定基础。

* 安全：

  * 生产开启最小 CSP（白名单内联样式/必要脚本指令），渲染层依旧通过 preload；保持 frameguard 关闭仅对需要的页面；令牌/敏感信息不落日志。

  * RateLimitManager 持久化策略（可选，按插件 ID）与白名单来源复核；API 代理端点鉴权与审计增强。

* <br />

