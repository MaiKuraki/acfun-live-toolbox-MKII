## 问题分析
- 进入控制台页面即出现大量重复的 ERROR 行，源于我们在主进程重写了 `console.error`，而 `LogManager.addLog` 内部又调用了 `console.error` 输出，导致递归调用（无限次 addLog → console.error → addLog）。
- 同时，渲染层调用 IPC `console:getCommands` 返回包含函数的命令对象（包含 `handler`），Electron 结构化克隆无法序列化函数，抛出 “An object could not be cloned”。

## 修复方案
1) 防止递归日志输出：
- 修改 `LogManager.addLog` 的控制台输出路径，使用 `process.stdout.write` / `process.stderr.write` 代替 `console.*`，避免与我们重写的 `console.*` 产生递归。
- 保留文件写入与消息中心发布逻辑不变。

2) 命令对象序列化：
- 在主进程 `ipcHandlers.ts` 的 `console:getCommands` IPC handler 中，将命令对象映射为可克隆的 DTO，仅返回 `name/description/usage/category`，不包含 `handler`。

## 验证点
- 打开控制台页面后不再出现 ERROR 刷屏；日志正常增量显示。
- `console:getCommands` 调用返回成功，前端展示命令元数据正常（即使当前 UI隐藏该卡片，也需确保调用不报错）。

## 影响范围
- 仅变更主进程日志输出与命令返回结构，兼容现有渲染层逻辑，其他功能不受影响。