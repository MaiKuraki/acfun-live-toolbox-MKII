<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>OBS 助手说明</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; margin: 0; padding: 16px; }
    h1 { font-size: 20px; margin: 0 0 12px; }
    .card { background: #fff; border: 1px solid #eee; border-radius: 10px; box-shadow: 0 6px 24px rgba(0,0,0,.06); padding: 14px; }
    ul { margin: 8px 0 0 18px; }
    li { line-height: 1.6; }
  </style>
  </head>
<body>
  <div class="card">
    <h1>OBS 助手</h1>
    <p id="obsStatus">OBS 连接状态：未知</p>
    <div style="margin:8px 0; color:#666; font-size:12px;">状态由后台自动连接与重试维护；如需自动启动，请在插件配置中选择 OBS 可执行文件路径。</div>
    <p>本插件用于：</p>
    <ul>
      <li>应用启动时自动检测并启动 OBS（需要配置 OBS 可执行路径）</li>
      <li>进入“创建直播”页面后自动同步推流服务器与串流密钥到 OBS</li>
      <li>支持配置 OBS WebSocket 服务端口与密码</li>
    </ul>
    <p>在插件管理页的配置项中设置：<code>obsPath</code>、<code>autoStartObs</code>、<code>syncStreaming</code>、<code>wsPort</code>、<code>wsPassword</code>。</p>
  </div>
  <script>
    (function(){
      function getBus(){ try { return (window.$wujie && window.$wujie.bus) || (window.__WUJIE && window.__WUJIE.bus) || (window.wujie && window.wujie.bus) || null; } catch(e){ return null; } }
      function getProps(){ try { return (window.__WUJIE && window.__WUJIE.props) || (window.$wujie && window.$wujie.props) || {}; } catch(e){ return {}; } }
      function requestOnce(command, payload){
        return new Promise(function(resolve, reject){
          var id = 'req-' + Date.now() + '-' + Math.random().toString(16).slice(2);
          var bus = getBus();
          function onResp(msg){ try { if(msg && msg.requestId === id){ bus.$off && bus.$off('bridge-response', onResp); if(msg.success){ resolve(msg.data); } else { reject(new Error(msg.error||'failed')); } } } catch(e){} }
          try { bus && bus.$on && bus.$on('bridge-response', onResp); bus && bus.$emit && bus.$emit('bridge-request', { type: 'bridge-request', requestId: id, command: command, payload: payload||{} }); } catch(e){}
          setTimeout(function(){ try { bus && bus.$off && bus.$off('bridge-response', onResp); } catch(e){} reject(new Error('timeout')); }, 10000);
        });
      }
      function requestWithRetry(command, payload, opts){
        var retries = (opts && opts.retries) || 5;
        var delayMs = (opts && opts.delayMs) || 400;
        function attempt(i){
          return requestOnce(command, payload).catch(function(err){
            var msg = String(err && err.message || err || '');
            if(i < retries && (msg.includes('busy') || msg.includes('timeout'))){
              return new Promise(function(r){ setTimeout(r, delayMs); }).then(function(){ return attempt(i+1); });
            }
            throw err;
          });
        }
        return attempt(0);
      }
      function renderStatus(data){ try { var el = document.getElementById('obsStatus'); if(!el) return; var s = (data && data.summary) ? data.summary : (data || {}); var conn = !!s.connected; var run = !!s.running; var connecting = !!s.connecting; var connText = connecting ? '连接中' : (conn ? '已连接' : '未连接'); var msg = 'OBS 连接状态：' + connText + '（' + (run ? '运行中' : '未运行') + '）'; var err = s.lastError ? String(s.lastError) : ''; var attempt = s.lastAttempt ? String(s.lastAttempt) : ''; if(err){ msg += '；错误：' + err + (attempt ? (' @ ' + attempt) : ''); } el.textContent = msg; } catch(e){} }
      function refresh(){
        requestWithRetry('process.execute', { method: 'getStatus' }, { retries: 5, delayMs: 400 })
          .then(renderStatus)
          .catch(function(){ try { var el = document.getElementById('obsStatus'); if(el) el.textContent = 'OBS 连接状态：未连接（未运行或插件忙）'; } catch(e){} });
      }
      function getApiBaseBridged(){ return requestWithRetry('get-api-base', {}).then(function(resp){ return String((resp&&resp.base)||''); }); }
      function subscribePluginOverlay(){
        var props = getProps();
        var pid = String((props&&props.pluginId)||'');
        if(!pid) return Promise.resolve(null);
        return getApiBaseBridged().then(function(base){
          var url = new URL('/sse/plugins/'+encodeURIComponent(pid)+'/overlay', base);
          var src = new EventSource(url.toString());
          function onEnv(ev){
            try {
              var env = JSON.parse(ev.data||'{}');
              console.log('[overlay:'+String(ev.type||'')+']', env);
            } catch(e){}
          }
          src.addEventListener('init', onEnv);
          src.addEventListener('update', onEnv);
          src.addEventListener('message', onEnv);
          src.addEventListener('action', onEnv);
          src.addEventListener('closed', onEnv);
          src.addEventListener('heartbeat', onEnv);
          src.onerror = function(){
            try { src.close(); } catch(e){}
            setTimeout(function(){ subscribePluginOverlay(); }, 3000);
          };
          return src;
        });
      }
      window.addEventListener('DOMContentLoaded', function(){
        var bus = getBus();
        try { bus && bus.$emit && bus.$emit('ui-ready', { type: 'ui-ready' }); } catch(e){}
        subscribePluginOverlay();
        try { if(bus && bus.$on){ bus.$on('plugin-init', refresh); bus.$on('plugin-event', function(msg){ try { if(msg && msg.eventType==='lifecycle' && (msg.event==='ready'||msg.event==='config-updated')) refresh(); } catch(e){} }); } } catch(e){}
        refresh();
      });
    })();
  </script>
</body>
</html>
